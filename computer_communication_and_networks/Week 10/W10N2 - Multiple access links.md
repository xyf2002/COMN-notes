Unlike point-to-point links, broadcast links may have several nodes each trying to send and receive. This means that access to the link must be coordinated, to prevent nodes from "talking over" each other resulting in garbled data being sent. This is controlled using **multiple access protocols**. Such a protocol should ideally have the following properties over an $R$ bits per second link:
1. If only one node has data to send, that node should have a throughput of $R$ bps
2. If $M$ nodes have data to send, then each of those nodes should have an average throughput of $R/M$ bps over a suitably defined interval of time
3. The protocol is decentralised, with no single control node
4. The protocol is simple to minimise implementation costs

There are 3 categories of multiple access protocols: channel partition, random access, and taking-turns protocols.
# Channel partitioning protocols
We have already looked at [[W2N1 - Network core#Time division multiplexing (TDM)|time division]] and [[W2N1 - Network core#Frequency division multiplexing (FDM)|frequency division]] multiplexing, and this is applicable again. TDM and FDM are both completely fair and prevent all collisions, but come at the cost that each slot is allocated to only one sender, so when some nodes don't have data to transmit the remaining nodes still have to leave empty frames/frequencies for it, violating property 4. A third channel division protocol is **code division multiple access (CDMA)**, which uses carefully selected codes to encode the data that is sent, which can allow multiple nodes to transmit simultaneously and still both be comprehensible to their targets.
# Random access protocols
A **random access protocol** has each node which desires to transmit do so at the full rate of the channel, $R$ bps, and when a collision occurs each node involved in that collision waits a random amount of time before trying again. As each node selects its delay independently, there is a chance that one of them will choose a sufficiently short delay such that it can send its full frame without a collision occurring.
## Slotted ALOHA
![[w10n2slottedAloha.png]]
**Slotted ALOHA** is one of the simplest random access protocol, which divides data into frames of $L$ bits, then divides time into slots of size $L/R$ seconds, meaning that 1 frame is fully transmitted in 1 slot. All nodes are synchronised, and a node can only transmit a frame at the beginning of a slot.
The process is straightforward:
- If a node has a frame to send it waits until the beginning of the next frame and sends the entire frame.
- If no collision occurs then the node has successfully transmitted its frame and is done.
- If a collision occurs, the node retransmits its frame in each subsequent slot with a fixed probability $p$
This makes slotted ALOHA a simple, decentralised protocol, and it allows any single active node to transmit at $R$ bps when there are no other active nodes on the network. Its efficient division of bandwidth between multiple active nodes is more complex.
When we have $N$ active nodes, the probability of a node transmitting is $p$, and so the probability that no other node transmits is $(p-1)^{N-1}$, therefore the probability that a given node has a success is $p(1-p)^{N-1}$. As there are $N$ nodes, the overall probability that any of the nodes has a success is $Np(1-p)^{N-1}$, and the efficiency of slotted ALOHA is $Np(1-p)^{N-1}$. The maximum efficiency for $N$ nodes requires finding the $p^*$ which maximises that expression. The maximum efficiency for a large number of nodes is $\lim_{N\rightarrow\infty}Np^*(1-p^*)^{N-1}$, which works out to $1/e=0.37$. Essentially, when there are a large number of nodes transmitting, no more than $0.37R$ is being used by successful transmission. Similar calculations show that 37% of slots go empty, and 26% have collisions.
## ALOHA
![[w10n2aloha.png]]
The slotted ALOHA protocol requires all nodes synchronise their transmissions, but the original ALOHA protocol was an unslotted, fully decentralised algorithm. In pure ALOHA, a node transmits its frame immediately, then if a collision occurs carries out the same $p$ probability of transmitting each slot. The difference here is that each node has unaligned slots. This means that nodes can begin transmissions while others are transmitting, or be interrupted part way through by another node starting transmission. This reduces the maximum efficiency to $1/(2e)$, which is the cost that comes with fully decentralising ALOHA.
## Carrier sense multiple access (CMSA)
**Carrier sense multiple access (CMSA)** develops the ALOHA idea by adding the rule that nodes should not start transmitting if another node is already transmitting. This rule doesn't prevent all collisions from occurring, as there is a propagation time for a signal from one node to reach another, and if two nodes start close enough together then a collision still occurs.
![[w10n2cmsa.png]]
Here, the x axis is where a signal has reached in space at the time on the y axis.
## Carrier sense multiple access with collision detection (CMSA/CD)
In pure CMSA, transmissions continue after a collision occurs, wasting a portion of bandwidth after the collision begins. By aborting transmission as quickly as possible after a collision occurs, most of that wasted bandwidth can be reclaimed.
![[w10n2cmsacd.png]]
A CMSA/CD node waits a random amount of time before retransmitting it, and it generates that wait time using the **binary exponential backoff** algorithm. In it, when a node has transmitted a frame it selects a value $K$ at random from $\{0,1,2,...,2^n-1\}$. This means that as a node experiences more collisions it will tend to (but not always) wait longer before retransmitting. For Ethernet, the actual wait time of a node is $K\cdot512\text{ bit times}$, and the maximum value of $N$ is 10. Ethernet also resets the collision count on each new frame, making it possible for a node to sneak another frame through immediately after a successful one, if the rest of the active nodes currently have high values of $n$.
### CMSA/CD efficiency
When only one node has frames to send, it can run at $R$ bps. The efficiency of CMSA/CD with a large number of active nodes each with a large number of frames to send is
$$
\text{Efficiency}=\frac{1}{1+\frac{5\cdot d_\text{prop}}{d_\text{trans}}}
$$
This means that as $d_\text{prop}$ approaches 0, the efficiency approaches 1 (as if there is no transmission delays a node always knows if any other is talking), and that as $d_\text{trans}$ grows, efficiency increases (as if a frame is transmitting for a very long period it will propagate to all other nodes, at which point it has claimed the channel to do useful work with).
## Taking turns protocols
There are a large number of taking turns protocols, which allow us to get higher bandwidth utilisation at the cost of durability. One approach is **polling**, where a node is selected as the master node, which polls each nodes in a round robin style. Each time, it tells anode that it may transmit a specific number of frames, and once the master detects no activity on the link it tells the next node to go. This achieves a much higher efficiency but there is still some efficiency loss from the time it takes the master to poll each node, and if the master node goes down the entire channel fails. A second approach is **token passing**, where a special frame known as the **token** is passed between nodes, and whichever node holds the token is the only one that can transmit. With a set order (1 sends the token to 2, 2 to 3, then 3 to 1) and rules on when to pass the token, this avoids having a single point of failure, but now care has to be taken to ensure that one node failing doesn't crash the channel, and to prevent a malicious node from being able to hold the token indefinitely.
## DOCSIS
![[w10n2docsis.png]]
**DOCSIS** is the link layer protocol used for cable internet access, and connects several thousand residences with cable modems to a **single cable modem termination system (CMTS)**. DOCSIS divides downstream (CMTS to modem) and upstream (modem to CMTS) lines using FDM into frequency bands of 6 Mhz on downstream with a maximum per channel throughput of around 40 Mbps, and upstream into 6.4 Mhz channels with a per channel throughput of around 30 Mbps. Frames transmitted on a downstream channel are received by all modems on that channel, but as only the CMTS transmits to it there are no collisions. The upstream channel is divided into time intervals using TDM, with each interval containing a number of minislots for frames to be transmitted in. The CMTS explicitly transmits MAP messages on the downstream channel to grant specific minislots to specific modems, and also grants some minislots to be used for minislot request frames. Modems send request frames in the request window at random, infer a collision has occurred if they do not receive an allocation in the next MAP message, and use binary exponential backoff to defer retransmitting its request.